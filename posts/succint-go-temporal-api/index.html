<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>A more succint Go Temporal API | 0x5d</title>
<meta name=keywords content="Go,Temporal"><meta name=description content="
The code for this post is available on GitHub
.

Temporal is a nice tool, providing a useful model for executing distributed processes along with the mechanisms you need to run them reliably, like retries & timeouts.
However the Go SDK can make your code very noisy. In a language where every line is really 3 or 4 lines,
res, err := doStuff()
if err != nil {
    return nil, err
}
any amplification of noise is very much unwelcome in my opinion."><meta name=author content><link rel=canonical href=https://blog.0x5d.io/posts/succint-go-temporal-api/><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.0x5d.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.0x5d.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.0x5d.io/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.0x5d.io/apple-touch-icon.png><link rel=mask-icon href=https://blog.0x5d.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.0x5d.io/posts/succint-go-temporal-api/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-9WWEFNQPEM"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9WWEFNQPEM")}</script><meta property="og:url" content="https://blog.0x5d.io/posts/succint-go-temporal-api/"><meta property="og:site_name" content="0x5d"><meta property="og:title" content="A more succint Go Temporal API"><meta property="og:description" content=" The code for this post is available on GitHub .
Temporal is a nice tool, providing a useful model for executing distributed processes along with the mechanisms you need to run them reliably, like retries & timeouts.
However the Go SDK can make your code very noisy. In a language where every line is really 3 or 4 lines,
res, err := doStuff() if err != nil { return nil, err } any amplification of noise is very much unwelcome in my opinion."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-08-17T15:11:47-05:00"><meta property="article:modified_time" content="2025-08-17T15:11:47-05:00"><meta property="article:tag" content="Go"><meta property="article:tag" content="Temporal"><meta name=twitter:card content="summary"><meta name=twitter:title content="A more succint Go Temporal API"><meta name=twitter:description content="
The code for this post is available on GitHub
.

Temporal is a nice tool, providing a useful model for executing distributed processes along with the mechanisms you need to run them reliably, like retries & timeouts.
However the Go SDK can make your code very noisy. In a language where every line is really 3 or 4 lines,
res, err := doStuff()
if err != nil {
    return nil, err
}
any amplification of noise is very much unwelcome in my opinion."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.0x5d.io/posts/"},{"@type":"ListItem","position":2,"name":"A more succint Go Temporal API","item":"https://blog.0x5d.io/posts/succint-go-temporal-api/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"A more succint Go Temporal API","name":"A more succint Go Temporal API","description":" The code for this post is available on GitHub .\nTemporal is a nice tool, providing a useful model for executing distributed processes along with the mechanisms you need to run them reliably, like retries \u0026amp; timeouts.\nHowever the Go SDK can make your code very noisy. In a language where every line is really 3 or 4 lines,\nres, err := doStuff() if err != nil { return nil, err } any amplification of noise is very much unwelcome in my opinion.\n","keywords":["Go","Temporal"],"articleBody":" The code for this post is available on GitHub .\nTemporal is a nice tool, providing a useful model for executing distributed processes along with the mechanisms you need to run them reliably, like retries \u0026 timeouts.\nHowever the Go SDK can make your code very noisy. In a language where every line is really 3 or 4 lines,\nres, err := doStuff() if err != nil { return nil, err } any amplification of noise is very much unwelcome in my opinion.\nThat’s why I took the opportunity when the need arose at work to start a new component from scratch, and explored alternative designs. Here’s the journey and the pattern I arrived at.\nThe explosion Go is a very simple language. Throughout my years writing it, I’ve learned to keep things simple and explicit. Let’s say we wanna create a function to fetch a URL and unmarshal its response from JSON into a struct. Ideally, our code would look something like the following. I will omit logging \u0026 metrics, which would add the same amount of noise across the alternatives we will explore.\nfunc FetchAndMarshal(ctx *context.Context, url string) (*Response, err) { rawBytes, err := fetchURL(ctx, url) if err != nil { return nil, err } return marshalResponse(rawBytes) } The caller code would look like so:\nres, err = FetchAndMarshal(ctx, url) if err != nil { return err } Now, let’s say we need to turn FetchAndMarshal into a Temporal workflow, executing fetchURL \u0026 marshalResponse as activities within it. Let’s see what that would (usually) do to the code.\nfunc FetchAndMarshal(ctx workflow.Context, url string) (*activities.Response, error) { fetchOpts := workflow.ActivityOptions{ StartToCloseTimeout: time.Minute, RetryPolicy: \u0026temporal.RetryPolicy{ InitialInterval: time.Second, BackoffCoefficient: 2.0, MaximumInterval: time.Minute, MaximumAttempts: 4, }, } ctx = workflow.WithActivityOptions(ctx, fetchOpts) var responseBody []byte err := workflow.ExecuteActivity(ctx, activities.FetchURLName, url).Get(ctx, \u0026responseBody) if err != nil { return nil, err } marshalOpts := workflow.ActivityOptions{ StartToCloseTimeout: 30 * time.Second, RetryPolicy: \u0026temporal.RetryPolicy{ InitialInterval: 500 * time.Millisecond, BackoffCoefficient: 1, MaximumInterval: time.Second, MaximumAttempts: 3, }, } ctx = workflow.WithActivityOptions(ctx, marshalOpts) var result *activities.Response err = workflow.ExecuteActivity(ctx, activities.MarshalResponseName, responseBody).Get(ctx, \u0026result) return result, err } And the caller…\nworkflowOptions := client.StartWorkflowOptions{ ID: \"fetch-and-marshal-workflow-\" + time.Now().Format(\"20060102-150405\"), TaskQueue: \"fetch-and-marshal-queue\", } var result *activities.Response we, err := c.ExecuteWorkflow(context.Background(), workflowOptions, workflows.FetchAndMarshalWorkflowName, url) if err != nil { return nil, err } return result, we.Get(context.Background(), \u0026result) The increase in lines of code, ignoring empty lines, is more than 3x. Keep in mind, this is a very small example - on a real codebase this could mean hundreds or thousands lines of accidental noise if it’s not kept in check.\nThe only redeeming quality of using the Temporal SDK API directly is its explicitness. You definitely know you’re executing a Temporal workflow or activity - not just calling a local function. This signals that you should at least expect some latency, as well as any and all errors that may come from using the network.\nYou also get flexibility: as you might have seen in the example above, the ActivityOptions embedded in the context passed to each activity’s corresponding ExecuteActivity are different.\nThat being said, I don’t think it’s worth it to pollute your code with all that noise, and you usually don’t need to change each activity’s timeouts \u0026 retry policy in the context of a specific workflow (they might be different across workflows, if the activities are reused).\nThe alternative Abstract the noise away.\nEvery call to ExecuteWorkflow and ExecuteActivity looks pretty much the same. Define the execution options, embed them in the context, execute the workflow or activity. Furthermore, redefining the execution options every single time (i.e. at every point each activity is executed) is often unnecessary, since they are usually inherent to the nature of the workflow or activity. Therefore, we should be able to define them once.\nBy defining an interface to get an activity’s metadata (name \u0026 options), we can refer to it instead of re-declaring the same values each time.\npackage activities import \"go.temporal.io/sdk/workflow\" type Meta struct { Name string Options *workflow.ActivityOptions } type ActivityMeta interface { Meta() *Meta } Here’s the ActivityMeta implementation for the FetchURL activity.\ntype FetchURL struct {/*fields*/} type FetchURLArgs struct { URL string `json:\"url\"` } func (*FetchURL) Meta() *Meta { return \u0026Meta{ Name: \"FetchURL\", Options: \u0026workflow.ActivityOptions{/*Default options*/}, } } Notice how we don’t need an actual instance of the struct. The function is “static”, so to speak (in Go terms: we’re using a nil receiver). We can do the same for MarshalResponse:\ntype MarshalResponse struct{} type MarshalResponseArgs struct { ResponseBody []byte `json:\"url\"` } func (*MarshalResponse) Meta() *Meta { return \u0026Meta{ Name: \"MarshalResponse\", Options: \u0026workflow.ActivityOptions{/*Default options*/}, } } We can then define a generic Execute function and simplify calling these and any activities we define.\npackage activities import ( \"go.temporal.io/sdk/workflow\" ) type Option func(o *workflow.ActivityOptions) func Execute[T any]( ctx workflow.Context, activity ActivityMeta, args any, opts ...Option, ) (*T, error) { meta := activity.Meta() if meta.Options == nil { meta.Options = \u0026workflow.ActivityOptions{} } for _, o := range opts { o(meta.Options) } future := workflow.ExecuteActivity( workflow.WithActivityOptions(ctx, *meta.Options), meta.Name, args, ) var res T return \u0026res, future.Get(ctx, \u0026res) } And then our workflow function becomes:\nfunc (*FetchAndMarshal) FetchAndMarshal(ctx workflow.Context, args *FetchAndMarshalArgs) (*activities.Response, error) { var fetch *activities.FetchURL responseBody, err := activities.Execute[[]byte](ctx, fetch, activities.FetchURLArgs{URL: args.URL}) if err != nil { return nil, err } var marshal *activities.MarshalResponse return activities.Execute[activities.Response](ctx, marshal, activities.MarshalResponseArgs{ResponseBody: *responseBody}) } This is so much nicer, in my opinion. It also restricts flexibility, but not by much - you can modify the ActivityOptions by defining and passing one or more Option functions to mutate them.\nThe pattern can also be replicated for workflows and child workflows. See the repo for an example .\nBonus: Self-Registration Keeping track of which workflow uses which activities is also painful when registration is done throughout the codebase. A saner way to do this is to have each workflow register itself and its activities. For example:\nfunc (fam *FetchAndMarshal) Register(w worker.Worker) { w.RegisterWorkflow(fam.FetchAndMarshal) w.RegisterActivity(activities.NewFetchURL().FetchURL) w.RegisterActivity(activities.NewMarshalResponse().MarshalResponse) } Registration in the workers becomes as easy as:\nw := worker.New(c, taskQueue, worker.Options{}) workflows.NewFetchAndMarshal().Register(w) This has the added benefit that it makes it obvious for anyone reading (especially humans) which workflows and activities are used by which parent workflow. Keep in mind that registering the same activity multiple times is idempotent (unless you register 2 activities with the same name on the same worker), so you can Register() many workflows even if they reuse the same activities.\n","wordCount":"1062","inLanguage":"en","datePublished":"2025-08-17T15:11:47-05:00","dateModified":"2025-08-17T15:11:47-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.0x5d.io/posts/succint-go-temporal-api/"},"publisher":{"@type":"Organization","name":"0x5d","logo":{"@type":"ImageObject","url":"https://blog.0x5d.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.0x5d.io/ accesskey=h title="0x5d (Alt + H)">0x5d</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://blog.0x5d.io/es/ title=Español aria-label=Español>Es</a></li></ul></div></div><ul id=menu><li><a href=https://blog.0x5d.io/archive/ title=archive><span>archive</span></a></li><li><a href=https://blog.0x5d.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://blog.0x5d.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">A more succint Go Temporal API</h1><div class=post-meta><span title='2025-08-17 15:11:47 -0500 -0500'>August 17, 2025</span></div></header><div class=post-content><blockquote><p>The code for this post is available on <a href=https://github.com/0x5d/temporal-example target=_blank>GitHub</a>
.</p></blockquote><p>Temporal is a nice tool, providing a useful model for executing distributed processes along with the mechanisms you need to run them reliably, like retries & timeouts.</p><p>However the Go SDK can make your code very noisy. In a language where every line is really 3 or 4 lines,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>res</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>doStuff</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>any amplification of noise is very much unwelcome in my opinion.</p><p>That&rsquo;s why I took the opportunity when the need arose at work to start a new component from scratch, and explored alternative designs. Here&rsquo;s the journey and the pattern I arrived at.</p><h2 id=the-explosion>The explosion<a hidden class=anchor aria-hidden=true href=#the-explosion>#</a></h2><p>Go is a very simple language. Throughout my years writing it, I&rsquo;ve learned to keep things simple and explicit.
Let&rsquo;s say we wanna create a function to fetch a URL and unmarshal its response from JSON into a struct. Ideally, our code would look something like the following. I will omit logging & metrics, which would add the same amount of noise across the alternatives we will explore.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>FetchAndMarshal</span><span class=p>(</span><span class=nx>ctx</span> <span class=o>*</span><span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>url</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=o>*</span><span class=nx>Response</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>rawBytes</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>fetchURL</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>url</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>marshalResponse</span><span class=p>(</span><span class=nx>rawBytes</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The caller code would look like so:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>res</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nf>FetchAndMarshal</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>url</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Now, let&rsquo;s say we need to turn <code>FetchAndMarshal</code> into a Temporal workflow, executing <code>fetchURL</code> & <code>marshalResponse</code> as activities within it. Let&rsquo;s see what that would (usually) do to the code.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>FetchAndMarshal</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>workflow</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>url</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=o>*</span><span class=nx>activities</span><span class=p>.</span><span class=nx>Response</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fetchOpts</span> <span class=o>:=</span> <span class=nx>workflow</span><span class=p>.</span><span class=nx>ActivityOptions</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>StartToCloseTimeout</span><span class=p>:</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Minute</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>RetryPolicy</span><span class=p>:</span> <span class=o>&amp;</span><span class=nx>temporal</span><span class=p>.</span><span class=nx>RetryPolicy</span><span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>InitialInterval</span><span class=p>:</span>    <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=nx>BackoffCoefficient</span><span class=p>:</span> <span class=mf>2.0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=nx>MaximumInterval</span><span class=p>:</span>    <span class=nx>time</span><span class=p>.</span><span class=nx>Minute</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=nx>MaximumAttempts</span><span class=p>:</span>    <span class=mi>4</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=p>},</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>ctx</span> <span class=p>=</span> <span class=nx>workflow</span><span class=p>.</span><span class=nf>WithActivityOptions</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>fetchOpts</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>responseBody</span> <span class=p>[]</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl>	<span class=nx>err</span> <span class=o>:=</span> <span class=nx>workflow</span><span class=p>.</span><span class=nf>ExecuteActivity</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>activities</span><span class=p>.</span><span class=nx>FetchURLName</span><span class=p>,</span> <span class=nx>url</span><span class=p>).</span><span class=nf>Get</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>responseBody</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>marshalOpts</span> <span class=o>:=</span> <span class=nx>workflow</span><span class=p>.</span><span class=nx>ActivityOptions</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>StartToCloseTimeout</span><span class=p>:</span> <span class=mi>30</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>RetryPolicy</span><span class=p>:</span> <span class=o>&amp;</span><span class=nx>temporal</span><span class=p>.</span><span class=nx>RetryPolicy</span><span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>InitialInterval</span><span class=p>:</span>    <span class=mi>500</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=nx>BackoffCoefficient</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=nx>MaximumInterval</span><span class=p>:</span>    <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			<span class=nx>MaximumAttempts</span><span class=p>:</span>    <span class=mi>3</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=p>},</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>ctx</span> <span class=p>=</span> <span class=nx>workflow</span><span class=p>.</span><span class=nf>WithActivityOptions</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>marshalOpts</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>result</span> <span class=o>*</span><span class=nx>activities</span><span class=p>.</span><span class=nx>Response</span>
</span></span><span class=line><span class=cl>	<span class=nx>err</span> <span class=p>=</span> <span class=nx>workflow</span><span class=p>.</span><span class=nf>ExecuteActivity</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>activities</span><span class=p>.</span><span class=nx>MarshalResponseName</span><span class=p>,</span> <span class=nx>responseBody</span><span class=p>).</span><span class=nf>Get</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>result</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>And the caller&mldr;</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>workflowOptions</span> <span class=o>:=</span> <span class=nx>client</span><span class=p>.</span><span class=nx>StartWorkflowOptions</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>ID</span><span class=p>:</span>        <span class=s>&#34;fetch-and-marshal-workflow-&#34;</span> <span class=o>+</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>Format</span><span class=p>(</span><span class=s>&#34;20060102-150405&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=nx>TaskQueue</span><span class=p>:</span> <span class=s>&#34;fetch-and-marshal-queue&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>result</span> <span class=o>*</span><span class=nx>activities</span><span class=p>.</span><span class=nx>Response</span>
</span></span><span class=line><span class=cl><span class=nx>we</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>c</span><span class=p>.</span><span class=nf>ExecuteWorkflow</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>(),</span> <span class=nx>workflowOptions</span><span class=p>,</span> <span class=nx>workflows</span><span class=p>.</span><span class=nx>FetchAndMarshalWorkflowName</span><span class=p>,</span> <span class=nx>url</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=nx>result</span><span class=p>,</span> <span class=nx>we</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>(),</span> <span class=o>&amp;</span><span class=nx>result</span><span class=p>)</span>
</span></span></code></pre></div><p>The increase in lines of code, ignoring empty lines, is more than 3x. Keep in mind, this is a very small example - on a real codebase this could mean hundreds or thousands lines of accidental noise if it&rsquo;s not kept in check.</p><p>The only redeeming quality of using the Temporal SDK API directly is its explicitness. You definitely know you&rsquo;re executing a Temporal workflow or activity - not just calling a local function. This signals that you should at least expect some latency, as well as any and all errors that may come from using the network.</p><p>You also get flexibility: as you might have seen in the example above, the <code>ActivityOptions</code> embedded in the context passed to each activity&rsquo;s corresponding <code>ExecuteActivity</code> are different.</p><p>That being said, I don&rsquo;t think it&rsquo;s worth it to pollute your code with all that noise, and you usually don&rsquo;t need to change each activity&rsquo;s timeouts & retry policy in the context of a specific workflow (they might be different across workflows, if the activities are reused).</p><h3 id=the-alternative>The alternative<a hidden class=anchor aria-hidden=true href=#the-alternative>#</a></h3><p>Abstract the noise away.</p><p>Every call to <code>ExecuteWorkflow</code> and <code>ExecuteActivity</code> looks pretty much the same. Define the execution options, embed them in the context, execute the workflow or activity. Furthermore, redefining the execution options every single time (i.e. at every point each activity is executed) is often unnecessary, since they are usually inherent to the nature of the workflow or activity. Therefore, we should be able to define them once.</p><p>By defining an interface to get an activity&rsquo;s metadata (name & options), we can refer to it instead of re-declaring the same values each time.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>activities</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;go.temporal.io/sdk/workflow&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Meta</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>Name</span>    <span class=kt>string</span>
</span></span><span class=line><span class=cl>	<span class=nx>Options</span> <span class=o>*</span><span class=nx>workflow</span><span class=p>.</span><span class=nx>ActivityOptions</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>ActivityMeta</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>Meta</span><span class=p>()</span> <span class=o>*</span><span class=nx>Meta</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Here&rsquo;s the <code>ActivityMeta</code> implementation for the <code>FetchURL</code> activity.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>FetchURL</span> <span class=kd>struct</span> <span class=p>{</span><span class=cm>/*fields*/</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>FetchURLArgs</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>URL</span> <span class=kt>string</span> <span class=s>`json:&#34;url&#34;`</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=o>*</span><span class=nx>FetchURL</span><span class=p>)</span> <span class=nf>Meta</span><span class=p>()</span> <span class=o>*</span><span class=nx>Meta</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=o>&amp;</span><span class=nx>Meta</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>Name</span><span class=p>:</span> <span class=s>&#34;FetchURL&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>Options</span><span class=p>:</span> <span class=o>&amp;</span><span class=nx>workflow</span><span class=p>.</span><span class=nx>ActivityOptions</span><span class=p>{</span><span class=cm>/*Default options*/</span><span class=p>},</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Notice how we don&rsquo;t need an actual instance of the struct. The function is &ldquo;static&rdquo;, so to speak (in Go terms: we&rsquo;re using a nil receiver). We can do the same for <code>MarshalResponse</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>MarshalResponse</span> <span class=kd>struct</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>MarshalResponseArgs</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>ResponseBody</span> <span class=p>[]</span><span class=kt>byte</span> <span class=s>`json:&#34;url&#34;`</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=o>*</span><span class=nx>MarshalResponse</span><span class=p>)</span> <span class=nf>Meta</span><span class=p>()</span> <span class=o>*</span><span class=nx>Meta</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=o>&amp;</span><span class=nx>Meta</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>Name</span><span class=p>:</span> <span class=s>&#34;MarshalResponse&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>Options</span><span class=p>:</span> <span class=o>&amp;</span><span class=nx>workflow</span><span class=p>.</span><span class=nx>ActivityOptions</span><span class=p>{</span><span class=cm>/*Default options*/</span><span class=p>},</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>We can then define a generic <code>Execute</code> function and simplify calling these and any activities we define.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>activities</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;go.temporal.io/sdk/workflow&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Option</span> <span class=kd>func</span><span class=p>(</span><span class=nx>o</span> <span class=o>*</span><span class=nx>workflow</span><span class=p>.</span><span class=nx>ActivityOptions</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nx>Execute</span><span class=p>[</span><span class=nx>T</span> <span class=nx>any</span><span class=p>](</span>
</span></span><span class=line><span class=cl>	<span class=nx>ctx</span> <span class=nx>workflow</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=nx>activity</span> <span class=nx>ActivityMeta</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=nx>args</span> <span class=nx>any</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=nx>opts</span> <span class=o>...</span><span class=nx>Option</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>)</span> <span class=p>(</span><span class=o>*</span><span class=nx>T</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>meta</span> <span class=o>:=</span> <span class=nx>activity</span><span class=p>.</span><span class=nf>Meta</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>meta</span><span class=p>.</span><span class=nx>Options</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>meta</span><span class=p>.</span><span class=nx>Options</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>workflow</span><span class=p>.</span><span class=nx>ActivityOptions</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>o</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>opts</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>o</span><span class=p>(</span><span class=nx>meta</span><span class=p>.</span><span class=nx>Options</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>future</span> <span class=o>:=</span> <span class=nx>workflow</span><span class=p>.</span><span class=nf>ExecuteActivity</span><span class=p>(</span>
</span></span><span class=line><span class=cl>		<span class=nx>workflow</span><span class=p>.</span><span class=nf>WithActivityOptions</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=o>*</span><span class=nx>meta</span><span class=p>.</span><span class=nx>Options</span><span class=p>),</span>
</span></span><span class=line><span class=cl>		<span class=nx>meta</span><span class=p>.</span><span class=nx>Name</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>args</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>res</span> <span class=nx>T</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=o>&amp;</span><span class=nx>res</span><span class=p>,</span> <span class=nx>future</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>res</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>And then our workflow function becomes:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=o>*</span><span class=nx>FetchAndMarshal</span><span class=p>)</span> <span class=nf>FetchAndMarshal</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>workflow</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>args</span> <span class=o>*</span><span class=nx>FetchAndMarshalArgs</span><span class=p>)</span> <span class=p>(</span><span class=o>*</span><span class=nx>activities</span><span class=p>.</span><span class=nx>Response</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>fetch</span> <span class=o>*</span><span class=nx>activities</span><span class=p>.</span><span class=nx>FetchURL</span>
</span></span><span class=line><span class=cl>	<span class=nx>responseBody</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>activities</span><span class=p>.</span><span class=nx>Execute</span><span class=p>[[]</span><span class=kt>byte</span><span class=p>](</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>fetch</span><span class=p>,</span> <span class=nx>activities</span><span class=p>.</span><span class=nx>FetchURLArgs</span><span class=p>{</span><span class=nx>URL</span><span class=p>:</span> <span class=nx>args</span><span class=p>.</span><span class=nx>URL</span><span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>marshal</span> <span class=o>*</span><span class=nx>activities</span><span class=p>.</span><span class=nx>MarshalResponse</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>activities</span><span class=p>.</span><span class=nx>Execute</span><span class=p>[</span><span class=nx>activities</span><span class=p>.</span><span class=nx>Response</span><span class=p>](</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>marshal</span><span class=p>,</span> <span class=nx>activities</span><span class=p>.</span><span class=nx>MarshalResponseArgs</span><span class=p>{</span><span class=nx>ResponseBody</span><span class=p>:</span> <span class=o>*</span><span class=nx>responseBody</span><span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This is so much nicer, in my opinion. It also restricts flexibility, but not by much - you can modify the <code>ActivityOptions</code> by defining and passing one or more <code>Option</code> functions to mutate them.</p><p>The pattern can also be replicated for workflows and child workflows. See the repo for an <a href=https://github.com/0x5d/temporal-example/blob/main/pkg/workflows/start.go target=_blank>example</a>
.</p><h3 id=bonus-self-registration>Bonus: Self-Registration<a hidden class=anchor aria-hidden=true href=#bonus-self-registration>#</a></h3><p>Keeping track of which workflow uses which activities is also painful when registration is done throughout the codebase. A saner way to do this is to have each workflow register itself and its activities. For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>fam</span> <span class=o>*</span><span class=nx>FetchAndMarshal</span><span class=p>)</span> <span class=nf>Register</span><span class=p>(</span><span class=nx>w</span> <span class=nx>worker</span><span class=p>.</span><span class=nx>Worker</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>w</span><span class=p>.</span><span class=nf>RegisterWorkflow</span><span class=p>(</span><span class=nx>fam</span><span class=p>.</span><span class=nx>FetchAndMarshal</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>w</span><span class=p>.</span><span class=nf>RegisterActivity</span><span class=p>(</span><span class=nx>activities</span><span class=p>.</span><span class=nf>NewFetchURL</span><span class=p>().</span><span class=nx>FetchURL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>w</span><span class=p>.</span><span class=nf>RegisterActivity</span><span class=p>(</span><span class=nx>activities</span><span class=p>.</span><span class=nf>NewMarshalResponse</span><span class=p>().</span><span class=nx>MarshalResponse</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Registration in the workers becomes as easy as:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>	<span class=nx>w</span> <span class=o>:=</span> <span class=nx>worker</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=nx>c</span><span class=p>,</span> <span class=nx>taskQueue</span><span class=p>,</span> <span class=nx>worker</span><span class=p>.</span><span class=nx>Options</span><span class=p>{})</span>
</span></span><span class=line><span class=cl>	<span class=nx>workflows</span><span class=p>.</span><span class=nf>NewFetchAndMarshal</span><span class=p>().</span><span class=nf>Register</span><span class=p>(</span><span class=nx>w</span><span class=p>)</span>
</span></span></code></pre></div><p>This has the added benefit that it makes it obvious for anyone reading (especially humans) which workflows and activities are used by which parent workflow. Keep in mind that registering the same activity multiple times is idempotent (unless you register 2 activities with the same name on the same worker), so you can <code>Register()</code> many workflows even if they reuse the same activities.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.0x5d.io/tags/go/>Go</a></li><li><a href=https://blog.0x5d.io/tags/temporal/>Temporal</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.0x5d.io/>0x5d</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>