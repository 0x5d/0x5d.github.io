<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Notes on Rust For Rustaceans, Pt. 1 | 0x5d</title>
<meta name=keywords content="rust"><meta name=description content="Intro
I&rsquo;m really enjoying reading Jon Gjenset
&rsquo;s Rust for Rustaceans
. I appreciated the author&rsquo;s decision to assume his target audience to be people who had just finished The Book
, making it sort of an expansion or a Level II.
However, I found it light on contrasting examples, as well as images. I&rsquo;m more of a visual learner, so I find them very useful to understand what&rsquo;s right (or wrong), or to help me create a mental model of a concept being described."><meta name=author content><link rel=canonical href=https://blog.0x5d.io/posts/rust-for-rustaceans/><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.0x5d.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.0x5d.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.0x5d.io/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.0x5d.io/apple-touch-icon.png><link rel=mask-icon href=https://blog.0x5d.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.0x5d.io/posts/rust-for-rustaceans/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-9WWEFNQPEM"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-9WWEFNQPEM")}</script><meta property="og:url" content="https://blog.0x5d.io/posts/rust-for-rustaceans/"><meta property="og:site_name" content="0x5d"><meta property="og:title" content="Notes on Rust For Rustaceans, Pt. 1"><meta property="og:description" content="Intro I’m really enjoying reading Jon Gjenset ’s Rust for Rustaceans . I appreciated the author’s decision to assume his target audience to be people who had just finished The Book , making it sort of an expansion or a Level II.
However, I found it light on contrasting examples, as well as images. I’m more of a visual learner, so I find them very useful to understand what’s right (or wrong), or to help me create a mental model of a concept being described."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-06-22T20:19:47-05:00"><meta property="article:modified_time" content="2024-06-23T20:19:47-05:00"><meta property="article:tag" content="Rust"><meta name=twitter:card content="summary"><meta name=twitter:title content="Notes on Rust For Rustaceans, Pt. 1"><meta name=twitter:description content="Intro
I&rsquo;m really enjoying reading Jon Gjenset
&rsquo;s Rust for Rustaceans
. I appreciated the author&rsquo;s decision to assume his target audience to be people who had just finished The Book
, making it sort of an expansion or a Level II.
However, I found it light on contrasting examples, as well as images. I&rsquo;m more of a visual learner, so I find them very useful to understand what&rsquo;s right (or wrong), or to help me create a mental model of a concept being described."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.0x5d.io/posts/"},{"@type":"ListItem","position":2,"name":"Notes on Rust For Rustaceans, Pt. 1","item":"https://blog.0x5d.io/posts/rust-for-rustaceans/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Notes on Rust For Rustaceans, Pt. 1","name":"Notes on Rust For Rustaceans, Pt. 1","description":"Intro I\u0026rsquo;m really enjoying reading Jon Gjenset \u0026rsquo;s Rust for Rustaceans . I appreciated the author\u0026rsquo;s decision to assume his target audience to be people who had just finished The Book , making it sort of an expansion or a Level II.\nHowever, I found it light on contrasting examples, as well as images. I\u0026rsquo;m more of a visual learner, so I find them very useful to understand what\u0026rsquo;s right (or wrong), or to help me create a mental model of a concept being described.\n","keywords":["rust"],"articleBody":"Intro I’m really enjoying reading Jon Gjenset ’s Rust for Rustaceans . I appreciated the author’s decision to assume his target audience to be people who had just finished The Book , making it sort of an expansion or a Level II.\nHowever, I found it light on contrasting examples, as well as images. I’m more of a visual learner, so I find them very useful to understand what’s right (or wrong), or to help me create a mental model of a concept being described.\nTherefore, to help me really grasp the topics discussed in the book, I’m writing the following notes. I decided to share them here in case they’re useful to someone else.\nℹ️ I have written some of these notes out of my own intuition. If you find an incorrect explanation, or consider my mental model for a concept to be wrong, please let me know !\nℹ️ This is a WIP. I’ll add more entries as I make progress through the book and write more examples \u0026 explanations.\n⚠️ All the base code snippets I’m quoting here are © 2022 John Gjengset. Please buy the book, it’s a must-read if you’re serious about learning Rust.\nI’m dividing the post by chapters \u0026 sections within them. There might be missing sections, which would mean I didn’t feel the need to supplement my reading with additional examples.\nAnyway, enough talking. Here it is.\nChapter 1: Foundations Section 1.3: Borrowing and Lifetimes Generic Lifetimes This subsection talks about how sometimes you need to specify different lifetimes for different fields in your types (making your type generic over multiple lifetimes). Here’s the example presented in the book (playground ).\nstruct StrSplit\u003c's, 'p\u003e { document: \u0026's str, delimiter: \u0026'p str, } impl\u003c's, 'p\u003e Iterator for StrSplit\u003c's, 'p\u003e { type Item = \u0026's str; fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e { todo!() } } fn str_before(s: \u0026str, c: char) -\u003e Option\u003c\u0026str\u003e { StrSplit {document: s, delimiter: \u0026c.to_string()}.next() } The author then mentions that making StrSplit generic over a single lifetime would cause a compilation error. Indeed, if we make the change… (playground )\nstruct StrSplit\u003c's\u003e { delimiter: \u0026's str, document: \u0026's str, } impl\u003c's\u003e Iterator for StrSplit\u003c's\u003e { // ... contents remain the same } fn str_before(s: \u0026str, c: char) -\u003e Option\u003c\u0026str\u003e { StrSplit {document: s, delimiter: \u0026c.to_string()}.next() } and run cargo build, we get the following error:\nerror[E0515]: cannot return value referencing temporary value --\u003e src/main_wrong.rs:14:5 | 14 | StrSplit {document: s, delimiter: \u0026c.to_string()}.next() | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-------------^^^^^^^^ | | | | | temporary value created here | returns a value referencing data owned by the current function It becomes more evident if we mark the lifetimes using the notation used in The Book:\n//---------------------------+- s \u0026 c are 'a fn str_before(s: \u0026str, c: char) -\u003e Option\u003c\u0026str\u003e {// | let delim = \u0026c.to_string(); //--+- delim must also be 'a | StrSplit { // | | document: s, // | | delimiter: delim, // | | } // | | .next() // | | //--+ delim is dropped | } // | //---------------------------+ s \u0026 c live on! delim’s timeline is shorter than s’s and c’s, causing a contradiction: 'a \u003c 'a.\nChapter 2: Types Section 2.2: Layout The explanation here comparing the default Rust in-memory representation vs the C-compatible one (repr(C)) is quite clear, but I thought a visual comparison would be helpful.\nThis is the example type used in the book:\n#[repr(C)] struct Foo { tiny: bool, normal: u32, small: u8, long: u64, short: u16, } As explained in page 21,\nComplex types - types that contain other types - are typically assigned the largest alignment of any type they contain.\nTherefore, this is its C-compatible layout, as described in page 22 (each square is 1B):\nBy visualizing it as a grid, it becomes clearer that the padding is determined by the field with the type that takes up the most space, long.\nAnd this would be Rust’s default layout (i.e. specifying #[repr(Rust)], or no repr attribute at all), which is 8B-aligned like the C-compatible layout, but which requires no padding between fields, reducing the total size to 16B.\nBonus Track: Alignment Modifiers The book doesn’t mention the alignment modifiers align and packed, which are only available for the C and Rust (default) representations, and can be used to “respectively raise or lower the alignment of structs and unions”.\nWhile reading about them, I again felt that their effects would be easier to understand and explain with a visual model.\npacked\nIf we add #[repr(C, packed(2))] to the Foo struct, the struct will be 2B-aligned. This is what it would look like (the “grid” visual model becomes less useful here, since padding and field alignment isn’t determined by a field’s size):\nThis can be verified with the following code (playground ):\nuse std::mem; #[repr(C, packed(2))] struct Foo { tiny: bool, normal: u32, small: u8, long: u64, short: u16, } fn main() { assert_eq!(mem::align_of::\u003cFoo\u003e(), 2); assert_eq!(mem::size_of::\u003cFoo\u003e(), 18); } The layout for repr(Rust, packed(2)) is still the same as the one before, since 16B is 2B-aligned there was no padding.\nalign\nAs mentioned above, align raises the alignment. If we add #[repr(align(32))] (default representation, 32B-aligned) to Foo, this is what we get:\nThis basically adds a 16B padding to the memory occupied by the type. Again, this can be checked with the following code (playground ).\nuse std::mem; #[repr(align(32))] struct Foo { tiny: bool, normal: u32, small: u8, long: u64, short: u16, } fn main() { assert_eq!(mem::align_of::\u003cFoo\u003e(), 32); assert_eq!(mem::size_of::\u003cFoo\u003e(), 32); } Trying out different values for packed and align was pretty interesting. I encourage anyone learning about them to do the same. You can also check your assumptions by first creating a layout diagram like the ones above (Excel works well, no need for fancy design software), and then asserting your guesses with align_of and size_of.\n","wordCount":"971","inLanguage":"en","datePublished":"2024-06-22T20:19:47-05:00","dateModified":"2024-06-23T20:19:47-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.0x5d.io/posts/rust-for-rustaceans/"},"publisher":{"@type":"Organization","name":"0x5d","logo":{"@type":"ImageObject","url":"https://blog.0x5d.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.0x5d.io/ accesskey=h title="0x5d (Alt + H)">0x5d</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://blog.0x5d.io/es/ title=Español aria-label=Español>Es</a></li></ul></div></div><ul id=menu><li><a href=https://blog.0x5d.io/archive/ title=archive><span>archive</span></a></li><li><a href=https://blog.0x5d.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://blog.0x5d.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Notes on Rust For Rustaceans, Pt. 1</h1><div class=post-meta><span title='2024-06-23 20:19:47 -0500 -0500'>June 23, 2024</span>&nbsp;·&nbsp;5 min</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#intro aria-label=Intro>Intro</a></li><li><a href=#chapter-1-foundations aria-label="Chapter 1: Foundations">Chapter 1: Foundations</a><ul><li><a href=#section-13-borrowing-and-lifetimes aria-label="Section 1.3: Borrowing and Lifetimes">Section 1.3: Borrowing and Lifetimes</a><ul><li><a href=#generic-lifetimes aria-label="Generic Lifetimes">Generic Lifetimes</a></li></ul></li></ul></li><li><a href=#chapter-2-types aria-label="Chapter 2: Types">Chapter 2: Types</a><ul><li><a href=#section-22-layout aria-label="Section 2.2: Layout">Section 2.2: Layout</a><ul><li><a href=#bonus-track-alignment-modifiers aria-label="Bonus Track: Alignment Modifiers">Bonus Track: Alignment Modifiers</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h2 id=intro>Intro<a hidden class=anchor aria-hidden=true href=#intro>#</a></h2><p>I&rsquo;m really enjoying reading <a href=https://x.com/jonhoo target=_blank>Jon Gjenset</a>
&rsquo;s <a href=https://rust-for-rustaceans.com/ target=_blank>Rust for Rustaceans</a>
. I appreciated the author&rsquo;s decision to assume his target audience to be people who had just finished <a href=https://doc.rust-lang.org/book/title-page.html target=_blank>The Book</a>
, making it sort of an expansion or a Level II.</p><p>However, I found it light on contrasting examples, as well as images. I&rsquo;m more of a visual learner, so I find them very useful to understand what&rsquo;s right (or wrong), or to help me create a mental model of a concept being described.</p><p>Therefore, to help me <em>really</em> grasp the topics discussed in the book, I&rsquo;m writing the following notes. I decided to share them here in case they&rsquo;re useful to someone else.</p><blockquote><p>ℹ️ I have written some of these notes out of my own intuition. If you find an incorrect explanation, or consider my mental model for a concept to be wrong, please <a href=https://x.com/_0x5d target=_blank>let me know</a>
!</p></blockquote><blockquote><p>ℹ️ This is a WIP. I&rsquo;ll add more entries as I make progress through the book and write more examples & explanations.</p></blockquote><blockquote><p>⚠️ All the base code snippets I&rsquo;m quoting here are © 2022 John Gjengset. Please buy the book, it&rsquo;s a must-read if you&rsquo;re serious about learning Rust.</p></blockquote><p>I&rsquo;m dividing the post by chapters & sections within them. There might be missing sections, which would mean I didn&rsquo;t feel the need to supplement my reading with additional examples.</p><p>Anyway, enough talking. Here it is.</p><h2 id=chapter-1-foundations>Chapter 1: Foundations<a hidden class=anchor aria-hidden=true href=#chapter-1-foundations>#</a></h2><h3 id=section-13-borrowing-and-lifetimes>Section 1.3: Borrowing and Lifetimes<a hidden class=anchor aria-hidden=true href=#section-13-borrowing-and-lifetimes>#</a></h3><h4 id=generic-lifetimes>Generic Lifetimes<a hidden class=anchor aria-hidden=true href=#generic-lifetimes>#</a></h4><p>This subsection talks about how sometimes you need to specify different lifetimes for different fields in your types (making your type generic over multiple lifetimes). Here&rsquo;s the example presented in the book (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=ad9612f66bea47604780afa0b053d5a6" target=_blank>playground</a>
).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>StrSplit</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;s</span>, <span style=color:#a6e22e>&#39;p</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    document: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;s</span> <span style=color:#66d9ef>str</span>,
</span></span><span style=display:flex><span>    delimiter: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;p</span> <span style=color:#66d9ef>str</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;s</span>, <span style=color:#a6e22e>&#39;p</span><span style=color:#f92672>&gt;</span> Iterator <span style=color:#66d9ef>for</span> StrSplit<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;s</span>, <span style=color:#a6e22e>&#39;p</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Item</span> <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>&#39;s</span> <span style=color:#66d9ef>str</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>next</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) -&gt; Option<span style=color:#f92672>&lt;</span>Self::Item<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        todo!()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>str_before</span>(s: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>, c: <span style=color:#66d9ef>char</span>) -&gt; Option<span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    StrSplit {document: <span style=color:#a6e22e>s</span>, delimiter: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>c</span>.to_string()}.next()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The author then mentions that making <code>StrSplit</code> generic over a single lifetime would cause a compilation error. Indeed, if we make the change&mldr; (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=2ea00b0cb451ded9f3430aca16e2eb00" target=_blank>playground</a>
)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>StrSplit</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;s</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    delimiter: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;s</span> <span style=color:#66d9ef>str</span>,
</span></span><span style=display:flex><span>    document: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>&#39;s</span> <span style=color:#66d9ef>str</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;s</span><span style=color:#f92672>&gt;</span> Iterator <span style=color:#66d9ef>for</span> StrSplit<span style=color:#f92672>&lt;</span><span style=color:#a6e22e>&#39;s</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... contents remain the same
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>str_before</span>(s: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>, c: <span style=color:#66d9ef>char</span>) -&gt; Option<span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    StrSplit {document: <span style=color:#a6e22e>s</span>, delimiter: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>c</span>.to_string()}.next()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>and run <code>cargo build</code>, we get the following error:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>error<span style=color:#f92672>[</span>E0515<span style=color:#f92672>]</span>: cannot <span style=color:#66d9ef>return</span> value referencing temporary value
</span></span><span style=display:flex><span>  --&gt; src/main_wrong.rs:14:5
</span></span><span style=display:flex><span>   |
</span></span><span style=display:flex><span><span style=color:#ae81ff>14</span> |     StrSplit <span style=color:#f92672>{</span>document: s, delimiter: &amp;c.to_string<span style=color:#f92672>()}</span>.next<span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-------------^^^^^^^^
</span></span><span style=display:flex><span>   |     |                                  |
</span></span><span style=display:flex><span>   |     |                                  temporary value created here
</span></span><span style=display:flex><span>   |     returns a value referencing data owned by the current <span style=color:#66d9ef>function</span>
</span></span></code></pre></div><p>It becomes more evident if we mark the lifetimes using the notation used in
The Book:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>                                <span style=color:#75715e>//---------------------------+- s &amp; c are &#39;a
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>str_before</span>(s: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>, c: <span style=color:#66d9ef>char</span>) -&gt; Option<span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span> {<span style=color:#75715e>//          |
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> delim <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>c.to_string(); <span style=color:#75715e>//--+- delim must also be &#39;a |
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    StrSplit {                  <span style=color:#75715e>//  |                        |
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        document: <span style=color:#a6e22e>s</span>,            <span style=color:#75715e>//  |                        |
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        delimiter: <span style=color:#a6e22e>delim</span>,       <span style=color:#75715e>//  |                        |
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }                           <span style=color:#75715e>//  |                        |
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    .next()                     <span style=color:#75715e>//  |                        |
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                <span style=color:#75715e>//--+ delim is dropped       |
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}                               <span style=color:#75715e>//                           |
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                <span style=color:#75715e>//---------------------------+ s &amp; c live on!
</span></span></span></code></pre></div><p><code>delim</code>&rsquo;s timeline is shorter than <code>s</code>&rsquo;s and <code>c</code>&rsquo;s, causing a contradiction: <code>'a</code> &lt; <code>'a</code>.</p><h2 id=chapter-2-types>Chapter 2: Types<a hidden class=anchor aria-hidden=true href=#chapter-2-types>#</a></h2><h3 id=section-22-layout>Section 2.2: Layout<a hidden class=anchor aria-hidden=true href=#section-22-layout>#</a></h3><p>The explanation here comparing the default Rust in-memory <a href=https://doc.rust-lang.org/reference/type-layout.html#representations target=_blank>representation</a>
vs the C-compatible one (<code>repr(C)</code>) is quite clear, but I thought a visual comparison would be helpful.</p><p>This is the example type used in the book:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[repr(C)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Foo</span> {
</span></span><span style=display:flex><span>    tiny: <span style=color:#66d9ef>bool</span>,
</span></span><span style=display:flex><span>    normal: <span style=color:#66d9ef>u32</span>,
</span></span><span style=display:flex><span>    small: <span style=color:#66d9ef>u8</span>,
</span></span><span style=display:flex><span>    long: <span style=color:#66d9ef>u64</span>,
</span></span><span style=display:flex><span>    short: <span style=color:#66d9ef>u16</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As explained in page 21,</p><blockquote><p><em>Complex types - types that contain other types - are typically assigned the largest alignment of any type they contain.</em></p></blockquote><p>Therefore, this is its C-compatible layout, as described in page 22 (each square is 1B):</p><p><img alt="Linear visualization of the C-compatible memory layout" loading=lazy src=/posts/rust-for-rustaceans/assets/c-linear.png></p><p>By visualizing it as a grid, it becomes clearer that the padding is determined by the field with the type that takes up the most space, <code>long</code>.</p><p><img alt="Grid visualization of the C-compatible memory layout" loading=lazy src=/posts/rust-for-rustaceans/assets/c-grid.png title="{width='350'}"></p><p>And this would be Rust&rsquo;s default layout (i.e. specifying <code>#[repr(Rust)]</code>, or no <code>repr</code> attribute at all), which is 8B-aligned like the C-compatible layout, but which requires no padding between fields, reducing the total size to 16B.</p><p><img alt="Grid visualization of Rust&rsquo;s default memory layout" loading=lazy src=/posts/rust-for-rustaceans/assets/rust-grid.png title="{width='350'}"></p><h4 id=bonus-track-alignment-modifiers>Bonus Track: Alignment Modifiers<a hidden class=anchor aria-hidden=true href=#bonus-track-alignment-modifiers>#</a></h4><p>The book doesn&rsquo;t mention the <a href=https://doc.rust-lang.org/reference/type-layout.html#the-alignment-modifiers target=_blank>alignment modifiers</a>
<code>align</code> and <code>packed</code>, which are only available for the <code>C</code> and <code>Rust</code> (default) representations, and can be used to &ldquo;respectively raise or lower the alignment of structs and unions&rdquo;.</p><p>While reading about them, I again felt that their effects would be easier to understand and explain with a visual model.</p><p><strong><code>packed</code></strong></p><p>If we add <code>#[repr(C, packed(2))]</code> to the <code>Foo</code> struct, the struct will be 2B-aligned. This is what it would look like (the &ldquo;grid&rdquo; visual model becomes less useful here, since padding and field alignment isn&rsquo;t determined by a field&rsquo;s size):</p><p><img alt="Linear visualization of the C-compatible memory layout, with packed(2)" loading=lazy src=/posts/rust-for-rustaceans/assets/c-linear-packed-2.png></p><p>This can be verified with the following code (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=91ca1cec472a98d66443df3e2ae1f485" target=_blank>playground</a>
):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::mem;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[repr(C, packed(2))]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Foo</span> {
</span></span><span style=display:flex><span>    tiny: <span style=color:#66d9ef>bool</span>,
</span></span><span style=display:flex><span>    normal: <span style=color:#66d9ef>u32</span>,
</span></span><span style=display:flex><span>    small: <span style=color:#66d9ef>u8</span>,
</span></span><span style=display:flex><span>    long: <span style=color:#66d9ef>u64</span>,
</span></span><span style=display:flex><span>    short: <span style=color:#66d9ef>u16</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    assert_eq!(mem::align_of::<span style=color:#f92672>&lt;</span>Foo<span style=color:#f92672>&gt;</span>(), <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>    assert_eq!(mem::size_of::<span style=color:#f92672>&lt;</span>Foo<span style=color:#f92672>&gt;</span>(), <span style=color:#ae81ff>18</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The layout for <code>repr(Rust, packed(2))</code> is still the same as the one before, since 16B is 2B-aligned there was no padding.</p><p><strong><code>align</code></strong></p><p>As mentioned above, <code>align</code> raises the alignment. If we add <code>#[repr(align(32))]</code> (default representation, 32B-aligned) to <code>Foo</code>, this is what we get:</p><p><img alt="Grid visualization of Rust&rsquo;s default memory layout, with align(32)" loading=lazy src=/posts/rust-for-rustaceans/assets/rust-grid-align-32.png title="{height='150'}"></p><p>This basically adds a 16B padding to the memory occupied by the type. Again, this can be checked with the following code (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=ba2571ce2a82b426568ad34cabc6e78c" target=_blank>playground</a>
).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::mem;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[repr(align(32))]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Foo</span> {
</span></span><span style=display:flex><span>    tiny: <span style=color:#66d9ef>bool</span>,
</span></span><span style=display:flex><span>    normal: <span style=color:#66d9ef>u32</span>,
</span></span><span style=display:flex><span>    small: <span style=color:#66d9ef>u8</span>,
</span></span><span style=display:flex><span>    long: <span style=color:#66d9ef>u64</span>,
</span></span><span style=display:flex><span>    short: <span style=color:#66d9ef>u16</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    assert_eq!(mem::align_of::<span style=color:#f92672>&lt;</span>Foo<span style=color:#f92672>&gt;</span>(), <span style=color:#ae81ff>32</span>);
</span></span><span style=display:flex><span>    assert_eq!(mem::size_of::<span style=color:#f92672>&lt;</span>Foo<span style=color:#f92672>&gt;</span>(), <span style=color:#ae81ff>32</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Trying out different values for <code>packed</code> and <code>align</code> was pretty interesting. I encourage anyone learning about them to do the same. You can also check your assumptions by first creating a layout diagram like the ones above (Excel works well, no need for fancy design software), and then asserting your guesses with <code>align_of</code> and <code>size_of</code>.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.0x5d.io/tags/rust/>Rust</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.0x5d.io/>0x5d</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>