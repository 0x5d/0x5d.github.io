<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Notes on Rust For Rustaceans, Pt. 1 | nerv</title>
<meta name=keywords content="rust">
<meta name=description content="Intro I&rsquo;m really enjoying reading Jon Gjenset&rsquo;s Rust for Rustaceans. I appreciated the author&rsquo;s decision to assume his target audience to be people who had just finished The Book, making it sort of an expansion or a Level II.
However, I found it light on contrasting examples, as well as images. I&rsquo;m more of a visual learner, so I find them very useful to understand what&rsquo;s right (or wrong), or to help me create a mental model of a concept being described.">
<meta name=author content>
<link rel=canonical href=http://0x5d.github.io/posts/rust-for-rustaceans/>
<link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://0x5d.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=http://0x5d.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=http://0x5d.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=http://0x5d.github.io/apple-touch-icon.png>
<link rel=mask-icon href=http://0x5d.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<link rel=alternate hreflang=en href=http://0x5d.github.io/posts/rust-for-rustaceans/>
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><meta property="og:title" content="Notes on Rust For Rustaceans, Pt. 1">
<meta property="og:description" content="Intro I&rsquo;m really enjoying reading Jon Gjenset&rsquo;s Rust for Rustaceans. I appreciated the author&rsquo;s decision to assume his target audience to be people who had just finished The Book, making it sort of an expansion or a Level II.
However, I found it light on contrasting examples, as well as images. I&rsquo;m more of a visual learner, so I find them very useful to understand what&rsquo;s right (or wrong), or to help me create a mental model of a concept being described.">
<meta property="og:type" content="article">
<meta property="og:url" content="http://0x5d.github.io/posts/rust-for-rustaceans/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2024-06-22T20:19:47-05:00">
<meta property="article:modified_time" content="2024-06-23T20:19:47-05:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Notes on Rust For Rustaceans, Pt. 1">
<meta name=twitter:description content="Intro I&rsquo;m really enjoying reading Jon Gjenset&rsquo;s Rust for Rustaceans. I appreciated the author&rsquo;s decision to assume his target audience to be people who had just finished The Book, making it sort of an expansion or a Level II.
However, I found it light on contrasting examples, as well as images. I&rsquo;m more of a visual learner, so I find them very useful to understand what&rsquo;s right (or wrong), or to help me create a mental model of a concept being described.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://0x5d.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Notes on Rust For Rustaceans, Pt. 1","item":"http://0x5d.github.io/posts/rust-for-rustaceans/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Notes on Rust For Rustaceans, Pt. 1","name":"Notes on Rust For Rustaceans, Pt. 1","description":"Intro I\u0026rsquo;m really enjoying reading Jon Gjenset\u0026rsquo;s Rust for Rustaceans. I appreciated the author\u0026rsquo;s decision to assume his target audience to be people who had just finished The Book, making it sort of an expansion or a Level II.\nHowever, I found it light on contrasting examples, as well as images. I\u0026rsquo;m more of a visual learner, so I find them very useful to understand what\u0026rsquo;s right (or wrong), or to help me create a mental model of a concept being described.","keywords":["rust"],"articleBody":"Intro I’m really enjoying reading Jon Gjenset’s Rust for Rustaceans. I appreciated the author’s decision to assume his target audience to be people who had just finished The Book, making it sort of an expansion or a Level II.\nHowever, I found it light on contrasting examples, as well as images. I’m more of a visual learner, so I find them very useful to understand what’s right (or wrong), or to help me create a mental model of a concept being described.\nTherefore, to help me really grasp the topics discussed in the book, I’m writing the following notes. I decided to share them here in case they’re useful to someone else.\n ℹ️ I have written some of these notes out of my own intuition. If you find an incorrect explanation, or consider my mental model for a concept to be wrong, please let me know!\n  ℹ️ This is a WIP. I’ll add more entries as I make progress through the book and write more examples \u0026 explanations.\n  ⚠️ All the base code snippets I’m quoting here are © 2022 John Gjengset. Please buy the book, it’s a must-read if you’re serious about learning Rust.\n I’m dividing the post by chapters \u0026 sections within them. There might be missing sections, which would mean I didn’t feel the need to supplement my reading with additional examples.\nAnyway, enough talking. Here it is.\nChapter 1: Foundations Section 1.3: Borrowing and Lifetimes Generic Lifetimes This subsection talks about how sometimes you need to specify different lifetimes for different fields in your types (making your type generic over multiple lifetimes). Here’s the example presented in the book.\nstruct StrSplits, 'p { document: \u0026's str, delimiter: \u0026'p str, } impls, 'p Iterator for StrSplits, 'p { type Item = \u0026's str; fn next(\u0026mut self) - OptionSelf::Item { todo!() } } fn str_before(s: \u0026str, c: char) - Optionstr { fn str_before(s: \u0026str, c: char) - Optionstr { StrSplit {document: s, delimiter: \u0026c.to_string()}.next() } } The author then mentions that making StrSplit generic over a single lifetime would cause a compilation error. Indeed, if we make the change…\nstruct StrSplits { delimiter: \u0026's str, document: \u0026's str, } impls Iterator for StrSplits { // ... contents remain the same } fn str_before(s: \u0026str, c: char) - Optionstr { StrSplit {document: s, delimiter: \u0026c.to_string()}.next() } and run cargo build, we get the following error:\nerror[E0515]: cannot return value referencing temporary value -- src/main_wrong.rs:14:5 | 14 | StrSplit {document: s, delimiter: \u0026c.to_string()}.next() | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-------------^^^^^^^^ | | | | | temporary value created here | returns a value referencing data owned by the current function It becomes more evident if we mark the lifetimes using the notation used in The Book:\n//---------------------------+- s \u0026 c are 'a fn str_before(s: \u0026str, c: char) - Optionstr {// |  let delim = \u0026c.to_string(); //--+- delim must also be 'a |  StrSplit { // | |  document: s, // | |  delimiter: delim, // | |  } // | |  .next() // | |  //--+ delim is dropped | } // |  //---------------------------+ s \u0026 c live on! delim’s timeline is shorter than s’s and c’s, causing a contradiction: 'a 'a.\nChapter 2: Types Section 2.2: Layout The explanation here comparing the default Rust in-memory representation vs the C-compatible one (repr(C)) is quite clear, but I thought a visual comparison would be helpful.\nThis is the example type used in the book:\n#[repr(C)] struct Foo { tiny: bool, normal: u32, small: u8, long: u64, short: u16, } As explained in page 21,\n Complex types - types that contain other types - are typically assigned the largest alignment of any type they contain.\n Therefore, this is its C-compatible layout, as described in page 22 (each square is 1B):\nBy visualizing it as a grid, it becomes clearer that the padding is determined by the field with the type that takes up the most space, long.\nAnd this would be Rust’s default layout (i.e. specifying #[repr(Rust)], or no repr attribute at all), which is 8B-aligned like the C-compatible layout, but which requires no padding between fields, reducing the total size to 16B.\nBonus Track: Alignment Modifiers The book doesn’t mention the alignment modifiers align and packed, which can be used to “respectively raise or lower the alignment of structs and unions”.\nWhile reading about them, I again felt that their effects would be easier to understand and explain with a visual model.\npacked\nIf we add #[repr(C, packed(2))] to the Foo struct, the struct will be 2B-aligned (i.e. each field’s value will start at 0, 2, 4, etc. bytes, adding padding as needed). This is what it would look like (the “grid” visual model becomes less useful here, since padding isn’t determined by a struct field’s size):\nThis can be verified with the following code:\nuse std::mem; #[repr(C, packed(2))] struct Foo { tiny: bool, normal: u32, small: u8, long: u64, short: u16, } fn main() { assert_eq!(mem::align_of::Foo(), 2); assert_eq!(mem::size_of::Foo(), 18); } The layout for repr(Rust, packed(2)) is still the same as the one before, since 16B is 2B-aligned there was no padding.\nalign\nAs mentioned above, align raises the alignment. If we add #[repr(align(32))] (default representation, 32B-aligned) to Foo, this is what we get:\nAgain, this can be checked with\nuse std::mem; #[repr(align(32))] struct Foo { tiny: bool, normal: u32, small: u8, long: u64, short: u16, } fn main() { assert_eq!(mem::align_of::Foo(), 32); assert_eq!(mem::size_of::Foo(), 32); } ","wordCount":"900","inLanguage":"en","datePublished":"2024-06-22T20:19:47-05:00","dateModified":"2024-06-23T20:19:47-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://0x5d.github.io/posts/rust-for-rustaceans/"},"publisher":{"@type":"Organization","name":"nerv","logo":{"@type":"ImageObject","url":"http://0x5d.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=http://0x5d.github.io/ accesskey=h title="nerv (Alt + H)">nerv</a>
<div class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
<ul class=lang-switch><li>|</li>
<li>
<a href=http://0x5d.github.io/es/ title=Español aria-label=Español>Es</a>
</li>
</ul>
</div>
</div>
<ul id=menu>
<li>
<a href=http://0x5d.github.io/archive/ title=archive>
<span>archive</span>
</a>
</li>
<li>
<a href=http://0x5d.github.io/search/ title="search (Alt + /)" accesskey=/>
<span>search</span>
</a>
</li>
<li>
<a href=http://0x5d.github.io/tags/ title=tags>
<span>tags</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
Notes on Rust For Rustaceans, Pt. 1
</h1>
<div class=post-meta><span title="2024-06-23 20:19:47 -0500 -0500">June 23, 2024</span>&nbsp;·&nbsp;5 min
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#intro aria-label=Intro>Intro</a></li>
<li>
<a href=#chapter-1-foundations aria-label="Chapter 1: Foundations">Chapter 1: Foundations</a><ul>
<li>
<a href=#section-13-borrowing-and-lifetimes aria-label="Section 1.3: Borrowing and Lifetimes">Section 1.3: Borrowing and Lifetimes</a><ul>
<li>
<a href=#generic-lifetimes aria-label="Generic Lifetimes">Generic Lifetimes</a></li></ul>
</li></ul>
</li>
<li>
<a href=#chapter-2-types aria-label="Chapter 2: Types">Chapter 2: Types</a><ul>
<li>
<a href=#section-22-layout aria-label="Section 2.2: Layout">Section 2.2: Layout</a><ul>
<li>
<a href=#bonus-track-alignment-modifiers aria-label="Bonus Track: Alignment Modifiers">Bonus Track: Alignment Modifiers</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><h2 id=intro>Intro<a hidden class=anchor aria-hidden=true href=#intro>#</a></h2>
<p>I&rsquo;m really enjoying reading <a href=https://x.com/jonhoo>Jon Gjenset</a>&rsquo;s <a href=https://rust-for-rustaceans.com/>Rust for Rustaceans</a>. I appreciated the author&rsquo;s decision to assume his target audience to be people who had just finished <a href=https://doc.rust-lang.org/book/title-page.html>The Book</a>, making it sort of an expansion or a Level II.</p>
<p>However, I found it light on contrasting examples, as well as images. I&rsquo;m more of a visual learner, so I find them very useful to understand what&rsquo;s right (or wrong), or to help me create a mental model of a concept being described.</p>
<p>Therefore, to help me <em>really</em> grasp the topics discussed in the book, I&rsquo;m writing the following notes. I decided to share them here in case they&rsquo;re useful to someone else.</p>
<blockquote>
<p>ℹ️ I have written some of these notes out of my own intuition. If you find an incorrect explanation, or consider my mental model for a concept to be wrong, please <a href=https://x.com/_0x5d>let me know</a>!</p>
</blockquote>
<blockquote>
<p>ℹ️ This is a WIP. I&rsquo;ll add more entries as I make progress through the book and write more examples & explanations.</p>
</blockquote>
<blockquote>
<p>⚠️ All the base code snippets I&rsquo;m quoting here are © 2022 John Gjengset. Please buy the book, it&rsquo;s a must-read if you&rsquo;re serious about learning Rust.</p>
</blockquote>
<p>I&rsquo;m dividing the post by chapters & sections within them. There might be missing sections, which would mean I didn&rsquo;t feel the need to supplement my reading with additional examples.</p>
<p>Anyway, enough talking. Here it is.</p>
<h2 id=chapter-1-foundations>Chapter 1: Foundations<a hidden class=anchor aria-hidden=true href=#chapter-1-foundations>#</a></h2>
<h3 id=section-13-borrowing-and-lifetimes>Section 1.3: Borrowing and Lifetimes<a hidden class=anchor aria-hidden=true href=#section-13-borrowing-and-lifetimes>#</a></h3>
<h4 id=generic-lifetimes>Generic Lifetimes<a hidden class=anchor aria-hidden=true href=#generic-lifetimes>#</a></h4>
<p>This subsection talks about how sometimes you need to specify different lifetimes for different fields in your types (making your type generic over multiple lifetimes). Here&rsquo;s the example presented in the book.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>StrSplit</span><span style=color:#f92672>&lt;&#39;</span><span style=color:#a6e22e>s</span>, <span style=color:#f92672>&#39;</span><span style=color:#a6e22e>p</span><span style=color:#f92672>&gt;</span> {
    document: <span style=color:#66d9ef>&amp;</span><span style=color:#f92672>&#39;</span><span style=color:#a6e22e>s</span> <span style=color:#66d9ef>str</span>,
    delimiter: <span style=color:#66d9ef>&amp;</span><span style=color:#f92672>&#39;</span><span style=color:#a6e22e>p</span> <span style=color:#66d9ef>str</span>,
}

<span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;&#39;</span><span style=color:#a6e22e>s</span>, <span style=color:#f92672>&#39;</span><span style=color:#a6e22e>p</span><span style=color:#f92672>&gt;</span> Iterator <span style=color:#66d9ef>for</span> StrSplit<span style=color:#f92672>&lt;&#39;</span><span style=color:#a6e22e>s</span>, <span style=color:#f92672>&#39;</span><span style=color:#a6e22e>p</span><span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Item</span> <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;&#39;</span><span style=color:#a6e22e>s</span> <span style=color:#66d9ef>str</span>;
    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>next</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) -&gt; Option<span style=color:#f92672>&lt;</span>Self::Item<span style=color:#f92672>&gt;</span> {
        todo!()
    }
}

<span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>str_before</span>(s: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>, c: <span style=color:#66d9ef>char</span>) -&gt; Option<span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>str_before</span>(s: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>, c: <span style=color:#66d9ef>char</span>) -&gt; Option<span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span> {
        StrSplit {document: <span style=color:#a6e22e>s</span>, delimiter: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>c</span>.to_string()}.next()
    }
}
</code></pre></div><p>The author then mentions that making <code>StrSplit</code> generic over a single lifetime would cause a compilation error. Indeed, if we make the change&mldr;</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>StrSplit</span><span style=color:#f92672>&lt;&#39;</span><span style=color:#a6e22e>s</span><span style=color:#f92672>&gt;</span> {
    delimiter: <span style=color:#66d9ef>&amp;</span><span style=color:#f92672>&#39;</span><span style=color:#a6e22e>s</span> <span style=color:#66d9ef>str</span>,
    document: <span style=color:#66d9ef>&amp;</span><span style=color:#f92672>&#39;</span><span style=color:#a6e22e>s</span> <span style=color:#66d9ef>str</span>,
}

<span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;&#39;</span><span style=color:#a6e22e>s</span><span style=color:#f92672>&gt;</span> Iterator <span style=color:#66d9ef>for</span> StrSplit<span style=color:#f92672>&lt;&#39;</span><span style=color:#a6e22e>s</span><span style=color:#f92672>&gt;</span> {
    <span style=color:#75715e>// ... contents remain the same
</span><span style=color:#75715e></span>}

<span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>str_before</span>(s: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>, c: <span style=color:#66d9ef>char</span>) -&gt; Option<span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span> {
    StrSplit {document: <span style=color:#a6e22e>s</span>, delimiter: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>c</span>.to_string()}.next()
}
</code></pre></div><p>and run <code>cargo build</code>, we get the following error:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>error<span style=color:#f92672>[</span>E0515<span style=color:#f92672>]</span>: cannot <span style=color:#66d9ef>return</span> value referencing temporary value
  --&gt; src/main_wrong.rs:14:5
   |
<span style=color:#ae81ff>14</span> |     StrSplit <span style=color:#f92672>{</span>document: s, delimiter: &amp;c.to_string<span style=color:#f92672>()}</span>.next<span style=color:#f92672>()</span>
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-------------^^^^^^^^
   |     |                                  |
   |     |                                  temporary value created here
   |     returns a value referencing data owned by the current <span style=color:#66d9ef>function</span>
</code></pre></div><p>It becomes more evident if we mark the lifetimes using the notation used in
The Book:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust>                                <span style=color:#75715e>//---------------------------+- s &amp; c are &#39;a
</span><span style=color:#75715e></span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>str_before</span>(s: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>, c: <span style=color:#66d9ef>char</span>) -&gt; Option<span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>str</span><span style=color:#f92672>&gt;</span> {<span style=color:#75715e>//          |
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> delim <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>c.to_string(); <span style=color:#75715e>//--+- delim must also be &#39;a |
</span><span style=color:#75715e></span>    StrSplit {                  <span style=color:#75715e>//  |                        |
</span><span style=color:#75715e></span>        document: <span style=color:#a6e22e>s</span>,            <span style=color:#75715e>//  |                        |
</span><span style=color:#75715e></span>        delimiter: <span style=color:#a6e22e>delim</span>,       <span style=color:#75715e>//  |                        |
</span><span style=color:#75715e></span>    }                           <span style=color:#75715e>//  |                        |
</span><span style=color:#75715e></span>    .next()                     <span style=color:#75715e>//  |                        |
</span><span style=color:#75715e></span>                                <span style=color:#75715e>//--+ delim is dropped       |
</span><span style=color:#75715e></span>}                               <span style=color:#75715e>//                           |
</span><span style=color:#75715e></span>                                <span style=color:#75715e>//---------------------------+ s &amp; c live on!
</span></code></pre></div><p><code>delim</code>&rsquo;s timeline is shorter than <code>s</code>&rsquo;s and <code>c</code>&rsquo;s, causing a contradiction: <code>'a</code> &lt; <code>'a</code>.</p>
<h2 id=chapter-2-types>Chapter 2: Types<a hidden class=anchor aria-hidden=true href=#chapter-2-types>#</a></h2>
<h3 id=section-22-layout>Section 2.2: Layout<a hidden class=anchor aria-hidden=true href=#section-22-layout>#</a></h3>
<p>The explanation here comparing the default Rust in-memory <a href=https://doc.rust-lang.org/reference/type-layout.html#representations>representation</a> vs the C-compatible one (<code>repr(C)</code>) is quite clear, but I thought a visual comparison would be helpful.</p>
<p>This is the example type used in the book:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#75715e>#[repr(C)]</span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Foo</span> {
    tiny: <span style=color:#66d9ef>bool</span>,
    normal: <span style=color:#66d9ef>u32</span>,
    small: <span style=color:#66d9ef>u8</span>,
    long: <span style=color:#66d9ef>u64</span>,
    short: <span style=color:#66d9ef>u16</span>,
}
</code></pre></div><p>As explained in page 21,</p>
<blockquote>
<p><em>Complex types - types that contain other types - are typically assigned the largest alignment of any type they contain.</em></p>
</blockquote>
<p>Therefore, this is its C-compatible layout, as described in page 22 (each square is 1B):</p>
<p><img loading=lazy src=assets/c-linear.png alt="Linear visualization of the C-compatible memory layout">
</p>
<p>By visualizing it as a grid, it becomes clearer that the padding is determined by the field with the type that takes up the most space, <code>long</code>.</p>
<p><img loading=lazy src=assets/c-linear.png alt="Grid visualization of the C-compatible memory layout" title="{width='350'}">
</p>
<p>And this would be Rust&rsquo;s default layout (i.e. specifying <code>#[repr(Rust)]</code>, or no <code>repr</code> attribute at all), which is 8B-aligned like the C-compatible layout, but which requires no padding between fields, reducing the total size to 16B.</p>
<p><img loading=lazy src=assets/c-linear.png alt="Grid visualization of Rust&amp;rsquo;s default memory layout" title="{width='350'}">
</p>
<h4 id=bonus-track-alignment-modifiers>Bonus Track: Alignment Modifiers<a hidden class=anchor aria-hidden=true href=#bonus-track-alignment-modifiers>#</a></h4>
<p>The book doesn&rsquo;t mention the <a href=https://doc.rust-lang.org/reference/type-layout.html#the-alignment-modifiers>alignment modifiers</a> <code>align</code> and <code>packed</code>, which can be used to &ldquo;respectively raise or lower the alignment of structs and unions&rdquo;.</p>
<p>While reading about them, I again felt that their effects would be easier to understand and explain with a visual model.</p>
<p><strong><code>packed</code></strong></p>
<p>If we add <code>#[repr(C, packed(2))]</code> to the <code>Foo</code> struct, the struct will be 2B-aligned (i.e. each field&rsquo;s value will start at 0, 2, 4, etc. bytes, adding padding as needed). This is what it would look like (the &ldquo;grid&rdquo; visual model becomes less useful here, since padding isn&rsquo;t determined by a struct field&rsquo;s size):</p>
<p><img loading=lazy src=assets/c-linear-packed-2.png alt="Linear visualization of the C-compatible memory layout, with packed(2)">
</p>
<p>This can be verified with the following code:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>use</span> std::mem;

<span style=color:#75715e>#[repr(C, packed(2))]</span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Foo</span> {
    tiny: <span style=color:#66d9ef>bool</span>,
    normal: <span style=color:#66d9ef>u32</span>,
    small: <span style=color:#66d9ef>u8</span>,
    long: <span style=color:#66d9ef>u64</span>,
    short: <span style=color:#66d9ef>u16</span>,
}

<span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
    assert_eq!(mem::align_of::<span style=color:#f92672>&lt;</span>Foo<span style=color:#f92672>&gt;</span>(), <span style=color:#ae81ff>2</span>);
    assert_eq!(mem::size_of::<span style=color:#f92672>&lt;</span>Foo<span style=color:#f92672>&gt;</span>(), <span style=color:#ae81ff>18</span>);
}
</code></pre></div><p>The layout for <code>repr(Rust, packed(2))</code> is still the same as the one before, since 16B is 2B-aligned there was no padding.</p>
<p><strong><code>align</code></strong></p>
<p>As mentioned above, <code>align</code> raises the alignment. If we add <code>#[repr(align(32))]</code> (default representation, 32B-aligned) to <code>Foo</code>, this is what we get:</p>
<p><img loading=lazy src=assets/c-linear.png alt="Grid visualization of Rust&amp;rsquo;s default memory layout, with align(32)" title="{height='150'}">
</p>
<p>Again, this can be checked with</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>use</span> std::mem;

<span style=color:#75715e>#[repr(align(32))]</span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Foo</span> {
    tiny: <span style=color:#66d9ef>bool</span>,
    normal: <span style=color:#66d9ef>u32</span>,
    small: <span style=color:#66d9ef>u8</span>,
    long: <span style=color:#66d9ef>u64</span>,
    short: <span style=color:#66d9ef>u16</span>,
}

<span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
    assert_eq!(mem::align_of::<span style=color:#f92672>&lt;</span>Foo<span style=color:#f92672>&gt;</span>(), <span style=color:#ae81ff>32</span>);
    assert_eq!(mem::size_of::<span style=color:#f92672>&lt;</span>Foo<span style=color:#f92672>&gt;</span>(), <span style=color:#ae81ff>32</span>);
}
</code></pre></div>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=http://0x5d.github.io/tags/rust/>rust</a></li>
</ul>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2024 <a href=http://0x5d.github.io/>nerv</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>